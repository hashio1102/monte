%% SIMULATE_SCOS_CONTRAST  Speckle contrast simulation driven by MCX photon transport.
% This script demonstrates how Monte Carlo eXtreme (MCX) outputs can be
% integrated with speckle contrast optical spectroscopy (SCOS) theory to
% recover blood flow index (BFi) values from noisy speckle contrast
% measurements. The workflow is:
%
%   1. Configure and launch MCX simulations for several source-detector
%      separations to obtain photon pathlength distributions.
%   2. Convert the detected photon statistics into electric field
%      autocorrelation curves g1(\tau) for arbitrary BFi values using the
%      path-integral form of the correlation diffusion solution.
%   3. Integrate |g1(\tau)|^2 over the camera exposure window to obtain the
%      speckle contrast that an SCOS instrument would measure.
%   4. Perform a nonlinear inversion that estimates BFi from noisy contrast
%      observations.
%
% The simulation requires the MCX/MCXlab toolbox. Ensure that `mcxlab` is on
% the MATLAB/Octave path before running this script. MCX executables are not
% distributed with this repository. Download MCX from https://mcx.space/.
%
% NOTE: This script records partial pathlengths in every detected photon.
% Depending on your MCX build, enabling `savedetflag='ppw'` can significantly
% increase the size of the detected photon list. Adjust the photon count and
% grid size to match your computational resources.
%
% Author: Generated by ChatGPT (OpenAI)

clear; clc;
close all;

if exist('mcxlab', 'file') ~= 2
    error(['MCXlab was not found on the MATLAB/Octave path. Install MCX and ' ...
           'add the mcxlab folder to your path before running this script.']);
end

%% Optical and acquisition parameters
params.optical.lambda = 785e-6;   % Wavelength [mm]
params.optical.n      = 1.37;     % Tissue refractive index
params.optical.alpha  = 1.0;      % Fraction of dynamic scatterers
params.optical.mu_a   = 0.010;    % Absorption [mm^-1]
params.optical.mu_sp  = 0.900;    % Reduced scattering [mm^-1]

params.beta           = 0.45;     % Speckle contrast factor (detector optics)
params.exposure       = 5e-3;     % Camera exposure time [s]
params.num_tau        = 6000;     % Integration samples for exposure integral

rho_mm = [15, 20, 30];            % Source-detector separations [mm]
BFi_grid = logspace(-9, -6, 60);  % Range of BFi values to explore [mm^2/s]

%% Launch MCX to obtain detected photon path statistics
fprintf('Running MCX simulations for %d separations...\n', numel(rho_mm));
[detectors, tau_axis] = run_mcx_simulation(rho_mm, params);

%% Build lookup table: speckle contrast as a function of BFi
K_lookup = zeros(numel(rho_mm), numel(BFi_grid));
for r_idx = 1:numel(rho_mm)
    det_data = detectors(r_idx);
    for db_idx = 1:numel(BFi_grid)
        Db = BFi_grid(db_idx);
        K_lookup(r_idx, db_idx) = contrast_from_paths(Db, det_data, tau_axis, params);
    end
end

figure('Name','Speckle contrast vs BFi','Color','w');
loglog(BFi_grid, K_lookup, 'LineWidth', 1.5);
xlabel('BFi [mm^2/s]');
ylabel('Speckle contrast K');
legend(arrayfun(@(r)sprintf('\\rho = %d mm', r), rho_mm, 'UniformOutput', false), ...
       'Location', 'southwest');
grid on;
set(gca, 'FontSize', 12);
title('Forward SCOS model driven by MCX pathlength statistics');

%% Generate synthetic noisy measurements at a single BFi
true_BFi = 4e-8;           % Ground-truth flow index [mm^2/s]
noise_level = 0.03;        % Relative Gaussian noise (3 % std)

K_true = zeros(size(rho_mm));
K_meas = zeros(size(rho_mm));
for r_idx = 1:numel(rho_mm)
    det_data = detectors(r_idx);
    K_true(r_idx) = contrast_from_paths(true_BFi, det_data, tau_axis, params);
    noisy = K_true(r_idx) * (1 + noise_level * randn());
    K_meas(r_idx) = max(noisy, 1e-6);  % avoid negative contrasts
end

%% Invert speckle contrast measurements to estimate BFi
initial_guess = 1e-8;  % Initial BFi guess [mm^2/s]
BFi_est = zeros(size(rho_mm));
for r_idx = 1:numel(rho_mm)
    det_data = detectors(r_idx);
    BFi_est(r_idx) = estimate_bfi_from_contrast(K_meas(r_idx), det_data, tau_axis, params, initial_guess);
end

%% Summarize the inversion results
results_table = table(rho_mm(:), K_true(:), K_meas(:), BFi_est(:), ...
    'VariableNames', {'Separation_mm', 'Contrast_true', 'Contrast_measured', 'BFi_estimated'});

fprintf('\nSynthetic SCOS inversion example (true BFi = %.2e mm^2/s)\n', true_BFi);
disp(results_table);

%% Plot g1(\tau) curves obtained from MCX pathlength statistics
figure('Name','g_1 correlation functions from MCX','Color','w');
hold on;
for r_idx = 1:numel(rho_mm)
    det_data = detectors(r_idx);
    tau_plot = logspace(-8, -2, 200);
    g1_curve = g1_from_paths(true_BFi, det_data, tau_plot, params);
    semilogx(tau_plot, real(g1_curve), 'LineWidth', 1.5, ...
        'DisplayName', sprintf('\\rho = %d mm', rho_mm(r_idx)));
end
hold off;
xlabel('\tau [s]');
ylabel('g_1(\tau)');
legend('Location', 'northeast');
grid on;
set(gca, 'FontSize', 12);
title(sprintf('Correlation decay from MCX photon paths (BFi = %.2e mm^2/s)', true_BFi));

%% Plot measured vs fitted contrast
figure('Name','Contrast fit comparison','Color','w');
bar_width = 0.35;
x = 1:numel(rho_mm);
bar(x - bar_width/2, K_true, bar_width, 'FaceColor', [0.2 0.4 0.8], 'EdgeColor', 'none');
hold on;
bar(x + bar_width/2, K_meas, bar_width, 'FaceColor', [0.9 0.4 0.2], 'EdgeColor', 'none');
model_fit = arrayfun(@(idx) contrast_from_paths(BFi_est(idx), detectors(idx), tau_axis, params), 1:numel(rho_mm));
scatter(x + bar_width/2, model_fit, 60, 'k', 'filled');
hold off;
set(gca, 'XTick', x, 'XTickLabel', arrayfun(@(r)sprintf('%.0f mm', r), rho_mm, 'UniformOutput', false));
xlabel('Source-detector separation');
ylabel('Speckle contrast K');
legend({'True contrast', 'Noisy measurement', 'Model fit'}, 'Location', 'best');
grid on;
set(gca, 'FontSize', 12);
title('Speckle contrast measurements and MCX-based model fit');

%% Helper functions
function [detectors, tau_axis] = run_mcx_simulation(rho_mm, params)
%RUN_MCX_SIMULATION Configure MCX and simulate all source-detector pairs.
%
%   detectors : struct array with MCX-derived photon statistics for each
%               detector. Fields include `pathlengths`, `weights`, and
%               `detector_id`.
%   tau_axis  : Correlation delay samples spanning the camera exposure.

    cfg = struct();
    cfg.nphoton    = 2e6;        % Adjust based on available compute
    cfg.tstart     = 0;
    cfg.tend       = 6e-9;       % 6 ns time window
    cfg.tstep      = 5e-12;      % 5 ps bins
    cfg.issrcfrom0 = 1;
    cfg.respin     = 0;
    cfg.unitinmm   = 1.0;        % Voxel size = 1 mm
    cfg.isreflect  = 1;
    cfg.isgpu      = 0;          % Use CPU by default
    cfg.detphotons = 1;          % Enable detection list
    cfg.savedetflag = 'ppw';     % record partial pathlengths + weight

    % Build a homogeneous slab volume (ensure detectors remain inside)
    nx = 120; ny = 120; nz = 50;
    cfg.vol = uint8(ones(nx, ny, nz));

    % Optical properties table: [mua mus g n]
    cfg.prop = [0 1 1 1; ...                   % Medium 0 (external)
                params.optical.mu_a, ...       % Medium 1 (tissue)
                params.optical.mu_sp / (1 - 0.9), ... % convert mus' to mus
                0.9, params.optical.n];

    % Source is a pencil beam located slightly below the top surface
    src_pos = [nx/2, ny/2, 2.0];
    cfg.srcpos = src_pos;
    cfg.srcdir = [0, 0, 1];

    % Place detectors at requested separations
    det_rows = zeros(numel(rho_mm), 4);
    for idx = 1:numel(rho_mm)
        rho = rho_mm(idx);
        det_rows(idx, :) = [src_pos(1) + rho, src_pos(2), src_pos(3), 1.0];
    end
    cfg.detpos = det_rows;

    fprintf('  Launching MCX with %d photons...\n', cfg.nphoton);
    [~, det] = mcxlab(cfg);

    if ~isfield(det, 'data') || isempty(det.data)
        error('MCX did not detect any photons. Increase photon count or detector size.');
    end

    if ~isfield(det, 'ppath')
        error(['MCX did not return partial pathlengths. Ensure savedetflag includes ''p'' ' ...
               'and that your MCX build supports this feature.']);
    end
    if size(det.ppath, 2) < 1
        error('MCX partial pathlength output does not contain tissue data.');
    end

    if ~isfield(det, 'weight')
        % Some MCX versions store weights in det.data(:,3)
        det.weight = det.data(:, 3);
    end

    det_id = get_detector_ids(det);
    tau_axis = linspace(0, params.exposure, params.num_tau);

    detectors = repmat(struct('detector_id', 0, 'pathlengths', [], 'weights', []), numel(rho_mm), 1);
    for idx = 1:numel(rho_mm)
        this_id = idx;
        mask = (det_id == this_id);
        if ~any(mask)
            error('Detector %d did not detect photons. Adjust simulation settings.', this_id);
        end
        detectors(idx).detector_id = this_id;
        detectors(idx).pathlengths = det.ppath(mask, 1); % tissue medium pathlengths
        detectors(idx).weights = det.weight(mask);
    end
end

function det_id = get_detector_ids(det)
%GET_DETECTOR_IDS Extract detector IDs from MCX detection data.
    if isfield(det, 'detid')
        det_id = det.detid;
    elseif size(det.data, 2) >= 1
        det_id = det.data(:, 1);
    else
        error('Unable to determine detector indices from MCX output.');
    end
end

function K = contrast_from_paths(Db, det_data, tau_axis, params)
%CONTRAST_FROM_PATHS Compute speckle contrast for a given BFi.
    g1 = g1_from_paths(Db, det_data, tau_axis, params);
    window = max(1 - tau_axis ./ params.exposure, 0);
    integrand = window .* abs(g1).^2;
    K_squared = params.beta / params.exposure * trapz(tau_axis, integrand);
    K = sqrt(max(K_squared, 0));
end

function g1 = g1_from_paths(Db, det_data, tau_axis, params)
%G1_FROM_PATHS Electric field autocorrelation from MCX photon paths.
    k0 = 2 * pi * params.optical.n / params.optical.lambda;
    alpha = params.optical.alpha;
    s = det_data.pathlengths(:);    % photon pathlengths in dynamic tissue [mm]
    w = det_data.weights(:);        % corresponding photon weights
    tau = tau_axis(:).';            % row vector for broadcasting

    decay = exp(-2 * (k0^2) * alpha * Db .* (s * tau));
    numerator = (w.' * decay);
    g1 = numerator / sum(w);
end

function Db_est = estimate_bfi_from_contrast(K_meas, det_data, tau_axis, params, initial_guess)
%ESTIMATE_BFI_FROM_CONTRAST Recover BFi from a speckle contrast measurement.
    if nargin < 5 || initial_guess <= 0
        initial_guess = 1e-8;
    end

    objective = @(log_Db) (contrast_from_paths(10.^log_Db, det_data, tau_axis, params) - K_meas).^2;
    opts = optimset('Display', 'off');
    log_Db_hat = fminsearch(objective, log10(initial_guess), opts);
    Db_est = 10.^log_Db_hat;
end
