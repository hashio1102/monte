function [depth_mm, contribution_fraction] = compute_depth_bfi_contribution(detpos, cfg)
%COMPUTE_DEPTH_BFI_CONTRIBUTION Estimate depth-wise photon contributions to BFi.
%   [DEPTH_MM, CONTRIBUTION_FRACTION] = COMPUTE_DEPTH_BFI_CONTRIBUTION(DETPOS, CFG)
%   integrates the partial path length information recorded by MCX for each
%   detector and converts it into a depth-resolved contribution profile.
%
%   Inputs
%       detpos : detector output struct array returned by MCX (mcxlab)
%       cfg    : configuration struct used for the simulation (contains VOL)
%
%   Outputs
%       depth_mm            : 1-by-N vector of depth bin centers in mm
%       contribution_fraction : Ndets-by-N array of fractional contributions
%                               per depth slice (sums to 1 for each detector)
%
%   Notes
%       * The function assumes that each depth slice (z-index) in cfg.vol has
%         a unique label (1..Nz). This is satisfied by the main simulation
%         script where cfg.vol(:,:,z) = z.
%       * The partial path length for each detected photon is weighted by the
%         photon weight (if saved) before accumulating contributions.
%       * If photon weights are not available, unit weights are used.
%
%   Author: Generated by ChatGPT (OpenAI)

arguments
    detpos (1,:) struct
    cfg struct
end

numdet = numel(detpos);
num_z  = size(cfg.vol, 3);

% Depth bin centers assuming cfg.unitinmm is defined in mm.
if isfield(cfg, 'unitinmm')
    depth_mm = ((1:num_z) - 0.5) * cfg.unitinmm;
else
    warning('cfg.unitinmm is not set; assuming 1 mm voxel spacing.');
    depth_mm = (1:num_z) - 0.5;
end

contribution_fraction = zeros(numdet, num_z);

for det_idx = 1:numdet
    [ppath, weight] = local_extract_ppath_and_weight(detpos(det_idx), num_z);
    if isempty(ppath)
        continue;
    end

    % Ensure vectors are double precision for numerical stability
    ppath = double(ppath(:, 1:num_z));
    weight = double(weight);

    if isempty(weight)
        weight = ones(size(ppath,1),1);
    else
        weight = weight(:);
    end

    weighted_paths = bsxfun(@times, ppath, weight);
    depth_sum = sum(weighted_paths, 1);

    if sum(depth_sum) > 0
        contribution_fraction(det_idx, :) = depth_sum ./ sum(depth_sum);
    end
end

end

function [ppath, weight] = local_extract_ppath_and_weight(det_entry, num_depth_bins)
%LOCAL_EXTRACT_PPATH_AND_WEIGHT Extract partial path lengths and weights
%   from an MCX detector entry. The function is robust to multiple saved
%   detector flag combinations and falls back to the 'data' matrix if
%   dedicated fields are not available.

ppath = [];
weight = [];

if isfield(det_entry, 'ppath') && ~isempty(det_entry.ppath)
    ppath = det_entry.ppath;
elseif isfield(det_entry, 'data') && ~isempty(det_entry.data)
    data = det_entry.data;
    if size(data,2) >= num_depth_bins
        ppath = data(:, end-num_depth_bins+1:end);
    end
else
    return;
end

if isfield(det_entry, 'weight') && ~isempty(det_entry.weight)
    weight = det_entry.weight;
elseif exist('data', 'var')
    extra_cols = size(data,2) - num_depth_bins;
    if extra_cols >= 1
        % Heuristically pick the last available column before the ppath
        weight = data(:, extra_cols);
    end
end

if ~isempty(weight) && size(weight,2) > 1
    weight = weight(:,1);
end

end
